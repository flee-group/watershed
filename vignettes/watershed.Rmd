---
title: "Delineating a watershed"
output: 
  rmarkdown::html_vignette:
  html_document:
vignette: >
  %\VignetteIndexEntry{Delineating a watershed}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
knitr::opts_chunk$set(fig.width=5.5, fig.height=5.5, collapse = TRUE, comment = "##", dev="png")
par(mar = c(0,0,0,0))
```

```{r setup}
library(watershed)
```


## 0. Preparing the installation

Be sure you have followed the installation guide and have a working installation of `watershed`, `rgrass7`, and Grass GIS 7.4 or 7.6 (other version may work, but are untested).

## 0.5. Preparing the DEM

Many workflows advise either using a "burned-in" DEM or a "filled" DEM to avoid topological problems. The tools used by `watershed` should in theory not require either of those steps, so in general it is recommended you skip this step unless you encounter problems later on. Burning in a DEM is not yet supported, so if this step is required it is best to use another tool and then bring the already burned DEM into R. Filling the DEM is supported however; see `?fill_dem`. 

## 1. Delineating the stream

The pared-down workflow offered by `watershed` provides a relatively quick way to go from a dem to a stream map. We will make a first-draft map using the `kamp_dem` dataset provided by this package, for the Ybbs river in Austria. The DEM is a `raster`, so we load this package as well.

```{r dem}
library(raster)
data(kamp_dem)
plot(kamp_dem, col=terrain.colors(20), axes = FALSE)
```

The `delineate()` function is the main workhorse here. The resulting raster stack contains 3 layers: `accum` is the flow accumulation, `drainage` is the drainage direction, and `stream` is the stream map. Note that the plotted stream looks "speckled" because it is a raster, and we don't plot every pixel to save time; later you will see how to produce a vector map of streams.

```{r delineate, cache = TRUE}
kamp = delineate(kamp_dem)
plot(kamp_dem, col=terrain.colors(20), axes = FALSE)
plot(kamp$stream, col='blue', add = TRUE, legend = FALSE)
```

The defaults produce pretty good results in this case. Perhaps we know from on-the-ground work, or aerial photo inspection, that there are more streams that what is produced here. We can improve this with the `threshold` parameter, which sets the default minimum basin size. This defaults to 1e6 m^2, or 1 km^2. Here we reduce it by half; note that this gives us a warning about possible long computation times; it's not such a problem here, because the Ybbs is a relatively small area, but with large DEMs this can make the computation very slow.

```{r delineate2, cache = TRUE}
kamp2 = delineate(kamp_dem, threshold = 0.5e5)
plot(kamp_dem, col=terrain.colors(20), axes = FALSE)
plot(kamp2$stream, col='blue', add = TRUE, legend = FALSE)

rm(kamp2)
```

This produces a lot of streams! From our fieldwork in the Kamp, we know that the default produces a pretty good network, so we will keep the first one.

## 2. Selecting a single basin

We would like to restrict our stream map to a single catchment. `delineate` offers this option; here we set `outlet = NA`, which will use the largest stream (with a catchment completely contained within the DEM) as the outlet for the desired basin. Alternatively, we could zoom in on the layer and choose the x-y coordinates of the outlet we wanted to use, and provide these as a vector in outlet.


```{r crop, cache = TRUE}
kamp = delineate(kamp_dem, outlet = NA)
## alternative - note that the coordinates must be exactly on the delineated stream
## for this to work
# kamp = delineate(kamp_dem, outlet = c(4704588, 2847762))
plot(kamp_dem, col=terrain.colors(20), axes = FALSE)
plot(kamp$stream, col='blue', add = TRUE, legend = FALSE, maxpixels=ncell(kamp$stream))
```

## 3. Generating topologies

Many later features require a topology; this simply a square matrix `T`, with one row/column for each pixel or reach in the river network. `T[i,j] == 1` indicates that pixel/reach `i` is directly upstream of pixel/reach `j` (in other words, `j` gets water from `i` without that water flowing through any other intermediate pixels/reaches).

Generating the topology can take some time for large and/or complex river networks, so it is best to do it once you have a reasonable first pass.

Our first step is to crop the rasters from the previous steps to only include our catchment of interest. Then we load the Matrix package to handle the `sparseMatrix` returned by `pixel_topology`. Finally, we create two topologies; one for the pixels, and one for reaches.

```{r topol, cache=TRUE}
catch = kamp$catchment
catch = trim(catch)
kamp = crop(kamp, catch)

library(Matrix)
kamp_Tp = pixel_topology(kamp)
kamp_reach_Tr = reach_topology(kamp, kamp_Tp)

```

Note the warning, indicating that there is a confluence where more than 2 streams flow into the same pixel. This is not a serious problem, so we will ignore it for now.


## 4. Revising the delineation


## 4. Producing smaller reaches

The default output from `delineate` is to assign each pixel to a reach, where a reach is a stretch of river between confluences. For many applications, it is useful to split these into smaller sections. `watershed` includes a function to split reaches into fixed (approximately) equal-length sections. Unequal-length reaches is a feature that may be added if we receive enough requests.

```{r reach_split, cache=TRUE}


```



## Producing a vector map

## Finer-scale control

## Computing catchment area

## Discharge and hydraulic geometry

## My network doesn't match aerial photos!
